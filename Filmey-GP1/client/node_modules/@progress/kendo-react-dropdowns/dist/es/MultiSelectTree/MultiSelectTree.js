var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { classNames, noop, useRtl, getTabIndex, Keys, guid } from '@progress/kendo-react-common';
import { Popup } from '@progress/kendo-react-popup';
import { useLocalization } from '@progress/kendo-react-intl';
import { TreeView } from '@progress/kendo-react-treeview';
import { validatePackage } from '@progress/kendo-react-common';
import { packageMetadata } from './../package-metadata';
import { getItemValue, areSame, matchTags } from '../common/utils';
import { useDropdownWidth } from './../DropDownTree/useDropdownWidth';
import { ListNoData } from './../DropDownTree/ListNoData';
import { messages, clear, nodata } from './../messages';
import { FloatingLabel } from '@progress/kendo-react-labels';
import TagList from '../MultiSelect/TagList';
var VALIDATION_MESSAGE = 'Please select a value from the list!';
var toLevel = function (hierarchicalIndex) {
    return hierarchicalIndex.split('_').map(function (i) { return parseInt(i, 10); });
};
var getValidity = function (_a, hasValue) {
    var validationMessage = _a.validationMessage, valid = _a.valid, required = _a.required;
    return ({
        customError: validationMessage !== undefined,
        valid: Boolean(valid !== undefined ? valid : (!required || hasValue)),
        valueMissing: !hasValue
    });
};
var defaultProps = {
    checkField: 'checkField',
    checkIndeterminateField: 'checkIndeterminateField',
    subItemsField: 'items',
    popupSettings: {
        animate: true,
        width: '200px',
        height: '200px'
    },
    required: false,
    validityStyles: true
};
/**
 * Represents the MultiSelectTree component.
 */
export var MultiSelectTree = React.forwardRef(function (props, ref) {
    validatePackage(packageMetadata);
    var componentGuid = React.useMemo(function () { return guid(); }, []);
    var id = props.id || componentGuid;
    var _a = props.data, data = _a === void 0 ? [] : _a, dataItemKey = props.dataItemKey, _b = props.popupSettings, popupSettings = _b === void 0 ? {} : _b, _c = props.style, style = _c === void 0 ? {} : _c, opened = props.opened, disabled = props.disabled, _d = props.onOpen, onOpen = _d === void 0 ? noop : _d, _e = props.onClose, onClose = _e === void 0 ? noop : _e, placeholder = props.placeholder, label = props.label, name = props.name, _f = props.checkField, checkField = _f === void 0 ? defaultProps.checkField : _f, _g = props.checkIndeterminateField, checkIndeterminateField = _g === void 0 ? defaultProps.checkIndeterminateField : _g, _h = props.subItemsField, subItemsField = _h === void 0 ? defaultProps.subItemsField : _h, validationMessage = props.validationMessage, valid = props.valid, tags = props.tags, value = props.value, _j = props.required, required = _j === void 0 ? defaultProps.required : _j, _k = props.validityStyles, validityStyles = _k === void 0 ? defaultProps.validityStyles : _k;
    var tabIndex = getTabIndex(props.tabIndex, disabled);
    var targetRef = React.useRef(null);
    var elementRef = React.useRef(null);
    var inputRef = React.useRef(null);
    var selectRef = React.useRef(null);
    var treeViewRef = React.useRef(null);
    var skipFocusRef = React.useRef(false);
    var tagsToRenderRef = React.useRef([]);
    var popupRef = React.useRef(null);
    var _l = React.useState(), focusedTagState = _l[0], setFocusedTagState = _l[1];
    var _m = React.useState(false), openState = _m[0], setOpenState = _m[1];
    var _o = React.useState(false), focusedState = _o[0], setFocusedState = _o[1];
    var _p = React.useState(''), filterState = _p[0], setFilterState = _p[1];
    var isOpen = opened !== undefined ? opened : openState;
    var hasValue = Boolean(Array.isArray(value) && value.length);
    var validity = getValidity({ validationMessage: validationMessage, valid: valid, required: required }, hasValue);
    var dir = useRtl(elementRef, props.dir);
    var initialStyleWidth = popupSettings.width !== undefined ?
        popupSettings.width : (style.width !== undefined ? style.width : defaultProps.popupSettings.width);
    var popupWidth = useDropdownWidth(elementRef, initialStyleWidth);
    var popupStyles = __assign({ width: popupWidth }, (dir !== undefined ? { direction: dir } : {}));
    var focus = React.useCallback(function () { return elementRef.current && elementRef.current.focus(); }, []);
    tagsToRenderRef.current = tags === undefined ?
        (value || []).map(function (item) { return ({ text: getItemValue(item, props.textField), data: [item] }); }) : tags.slice();
    React.useImperativeHandle(targetRef, function () { return ({
        props: props,
        element: elementRef.current,
        actionElement: elementRef.current,
        focus: focus
    }); });
    React.useImperativeHandle(ref, function () { return targetRef.current; });
    var setValidity = React.useCallback(function () {
        if (selectRef.current && selectRef.current.setCustomValidity) {
            selectRef.current.setCustomValidity(validity.valid
                ? ''
                : validationMessage === undefined ? VALIDATION_MESSAGE : validationMessage);
        }
    }, [validationMessage, validity]);
    React.useEffect(setValidity);
    React.useEffect(function () {
        if (popupRef.current && isOpen) {
            popupRef.current.setPosition(popupRef.current._popup);
        }
    }, [value, isOpen]);
    var changeValue = React.useCallback(function (event, relatedItems, operation) {
        if (props.onChange) {
            var changeEvent = __assign({ items: relatedItems, operation: operation }, event);
            props.onChange.call(undefined, changeEvent);
        }
    }, [props.onChange]);
    var onChange = React.useCallback(function (event) {
        if (areSame(event.item, value, dataItemKey) || !targetRef.current) {
            return;
        }
        var item = event.item, nativeEvent = event.nativeEvent, syntheticEvent = event.syntheticEvent;
        var ev = {
            syntheticEvent: syntheticEvent,
            nativeEvent: nativeEvent,
            target: targetRef.current
        };
        changeValue(ev, [item], 'toggle');
    }, [value, dataItemKey, changeValue]);
    var openPopup = React.useCallback(function (event) {
        if (!isOpen) {
            if (onOpen) {
                var openEvent = __assign({}, event);
                onOpen.call(undefined, openEvent);
            }
            if (opened === undefined) {
                setOpenState(true);
            }
        }
    }, [isOpen, opened, onOpen]);
    var closePopup = React.useCallback(function (event) {
        if (isOpen) {
            if (onClose) {
                var closeEvent = __assign({}, event);
                onClose.call(undefined, closeEvent);
            }
            if (opened === undefined) {
                setOpenState(false);
            }
        }
    }, [isOpen, opened, onClose]);
    var switchFocus = React.useCallback(function (focusFn) {
        skipFocusRef.current = true;
        focusFn();
        window.setTimeout(function () { return skipFocusRef.current = false; }, 0);
    }, []);
    var focusElement = React.useCallback(function (element) {
        if (element) {
            switchFocus(function () { return element.focus(); });
        }
    }, [switchFocus]);
    var onPopupOpened = React.useCallback(function () {
        if (!focusedState && isOpen) {
            closePopup({ target: targetRef.current });
        }
        else {
            if (props.filterable) {
                focusElement(inputRef.current);
            }
            else {
                focusElement(treeViewRef.current && treeViewRef.current.element);
            }
        }
    }, [focusedState, isOpen, focusElement, closePopup, props.filterable]);
    var onPopupClosed = React.useCallback(function () {
        if (focusedState) {
            // Move the focus from treeview to dropdown without triggering Focus or Blur events.
            focusElement(elementRef.current);
        }
    }, [focusedState, focusElement]);
    var onFocus = React.useCallback(function (event) {
        if (!focusedState && !skipFocusRef.current) {
            setFocusedState(true);
            if (props.onFocus && targetRef.current) {
                var focusEvent = {
                    syntheticEvent: event,
                    nativeEvent: event.nativeEvent,
                    target: targetRef.current
                };
                props.onFocus.call(undefined, focusEvent);
            }
        }
    }, [focusedState, props.onFocus]);
    var onBlur = React.useCallback(function (event) {
        if (focusedState && !skipFocusRef.current && targetRef.current) {
            setFocusedState(false);
            var ev = {
                syntheticEvent: event,
                nativeEvent: event.nativeEvent,
                target: targetRef.current
            };
            if (props.onBlur) {
                var focusEvent = __assign({}, ev);
                props.onBlur.call(undefined, focusEvent);
            }
            closePopup(ev);
        }
    }, [focusedState, props.onBlur, isOpen, opened, onClose]);
    var onWrapperMouseDown = React.useCallback(function () {
        if (focusedState) {
            // moving focus from treeview to dropdown triggers Focus and Blur events.
            switchFocus(noop);
        }
    }, [focusedState, switchFocus]);
    var onWrapperClick = React.useCallback(function (event) {
        if (!event.isDefaultPrevented() && targetRef.current) {
            setFocusedState(true);
            var ev = {
                syntheticEvent: event,
                nativeEvent: event.nativeEvent,
                target: targetRef.current
            };
            if (!isOpen) {
                openPopup(ev);
            }
        }
    }, [isOpen, openPopup]);
    var onWrapperKeyDown = React.useCallback(function (event) {
        var keyCode = event.keyCode, altKey = event.altKey;
        var treeviewElement = treeViewRef.current && treeViewRef.current.element;
        if (!targetRef.current || (event.isDefaultPrevented() && inputRef.current === event.target)) {
            return;
        }
        var ev = {
            syntheticEvent: event,
            nativeEvent: event.nativeEvent,
            target: targetRef.current
        };
        if (value && value.length > 0 &&
            (keyCode === Keys.left || keyCode === Keys.right ||
                keyCode === Keys.home || keyCode === Keys.end ||
                keyCode === Keys.delete)) {
            var tagsToRender = tagsToRenderRef.current;
            var focusedIndex = focusedTagState ?
                tagsToRender.findIndex(function (t) { return matchTags(t, focusedTagState, dataItemKey); }) : -1;
            var newFocusedTag = undefined;
            var hasFocused = focusedIndex !== -1;
            if (keyCode === Keys.left) {
                if (hasFocused) {
                    focusedIndex = Math.max(0, focusedIndex - 1);
                }
                else {
                    focusedIndex = tagsToRender.length - 1;
                }
                newFocusedTag = tagsToRender[focusedIndex];
            }
            else if (keyCode === Keys.right) {
                if (focusedIndex === tagsToRender.length - 1) {
                    newFocusedTag = undefined;
                }
                else if (hasFocused) {
                    focusedIndex = Math.min(tagsToRender.length - 1, focusedIndex + 1);
                    newFocusedTag = tagsToRender[focusedIndex];
                }
            }
            else if (keyCode === Keys.home) {
                newFocusedTag = tagsToRender[0];
            }
            else if (keyCode === Keys.end) {
                newFocusedTag = tagsToRender[tagsToRender.length - 1];
            }
            else if (keyCode === Keys.delete) {
                if (hasFocused) {
                    changeValue(ev, tagsToRender[focusedIndex].data, 'delete');
                }
            }
            if (newFocusedTag !== focusedTagState) {
                setFocusedTagState(newFocusedTag);
            }
        }
        if (isOpen) {
            if (keyCode === Keys.esc || (altKey && keyCode === Keys.up)) {
                closePopup(ev);
            }
            else if (treeviewElement && treeviewElement.querySelector('.k-state-focused') &&
                (keyCode === Keys.up || keyCode === Keys.down ||
                    keyCode === Keys.left || keyCode === Keys.right ||
                    keyCode === Keys.home || keyCode === Keys.end)) {
                if (keyCode === Keys.up && inputRef.current) {
                    var items = Array.from(treeviewElement.querySelectorAll('.k-treeview-item'));
                    var focusedItem = items.slice().reverse().find(function (i) { return Boolean(i && i.querySelector('.k-state-focused')); });
                    if (focusedItem && items.indexOf(focusedItem) === 0) {
                        return switchFocus(function () { focusElement(inputRef.current); });
                    }
                }
                switchFocus(noop);
            }
            else if (keyCode === Keys.down) {
                switchFocus(function () { focusElement(inputRef.current || treeviewElement); });
            }
        }
        else {
            if (altKey && keyCode === Keys.down) {
                openPopup(ev);
            }
        }
    }, [isOpen, closePopup, focusElement, switchFocus, openPopup, focusedTagState, dataItemKey, value, changeValue]);
    var onInputKeyDown = React.useCallback(function (event) {
        var keyCode = event.keyCode, altKey = event.altKey;
        if (altKey || (keyCode !== Keys.up && keyCode !== Keys.down)) {
            return;
        }
        event.preventDefault();
        switchFocus(keyCode === Keys.up ?
            function () { focusElement(elementRef.current); } :
            function () { focusElement(treeViewRef.current && treeViewRef.current.element); });
    }, [focusElement, switchFocus]);
    var onClear = React.useCallback(function (event) {
        if (!targetRef.current) {
            return;
        }
        var ev = {
            syntheticEvent: event,
            nativeEvent: event.nativeEvent,
            target: targetRef.current
        };
        changeValue(ev, [], 'clear');
        closePopup(ev);
        event.preventDefault();
    }, [changeValue, closePopup]);
    var onTagDelete = React.useCallback(function (itemsToRemove, event) {
        closePopup({ target: targetRef.current });
        if (!focusedState) {
            focusElement(inputRef.current);
        }
        changeValue({
            syntheticEvent: event,
            nativeEvent: event.nativeEvent,
            target: targetRef.current
        }, itemsToRemove, 'delete');
    }, [changeValue, closePopup, focusElement, focusedState]);
    var onExpand = React.useCallback(function (event) {
        if (props.onExpandChange && targetRef.current) {
            var item = event.item, itemHierarchicalIndex = event.itemHierarchicalIndex, nativeEvent = event.nativeEvent, syntheticEvent = event.syntheticEvent;
            var expandEvent = {
                level: toLevel(itemHierarchicalIndex),
                item: item, nativeEvent: nativeEvent, syntheticEvent: syntheticEvent, target: targetRef.current
            };
            props.onExpandChange.call(undefined, expandEvent);
        }
    }, [props.onExpandChange]);
    var onFilterChange = React.useCallback(function (event) {
        if (props.onFilterChange && targetRef.current) {
            var filterDesc = { field: props.textField, operator: 'contains', value: event.target.value };
            var ev = {
                filter: filterDesc,
                syntheticEvent: event,
                nativeEvent: event.nativeEvent,
                target: targetRef.current
            };
            props.onFilterChange.call(undefined, ev);
            if (props.filter === undefined) {
                setFilterState(event.target.value);
            }
        }
    }, [props.onFilterChange, props.filter, props.textField]);
    var NoData = props.listNoData || ListNoData;
    var localization = useLocalization();
    var isValid = !validityStyles || validity.valid;
    var multiselecttree = (React.createElement("span", { className: classNames('k-widget k-dropdowntree', props.className, {
            'k-state-focused': focusedState && !disabled,
            'k-state-invalid': !isValid,
            'k-state-disabled': disabled
        }), tabIndex: tabIndex, accessKey: props.accessKey, id: id, style: label ? __assign({}, style, { width: undefined }) : style, dir: dir, ref: elementRef, onKeyDown: disabled ? undefined : onWrapperKeyDown, onMouseDown: onWrapperMouseDown, onFocus: onFocus, onBlur: onBlur, role: "listbox", "aria-haspopup": "true", "aria-expanded": isOpen, "aria-disabled": disabled, "aria-label": label, "aria-labelledby": props.ariaLabelledBy, "aria-describedby": props.ariaDescribedBy },
        React.createElement("span", { className: classNames('k-multiselect-wrap k-floatwrap', {
                'k-state-focused': focusedState,
                'k-state-disabled': disabled,
                'k-state-invalid': !isValid
            }), onClick: disabled ? undefined : onWrapperClick },
            tagsToRenderRef.current.length > 0 && (React.createElement(TagList, { tag: props.tag, onTagDelete: onTagDelete, data: tagsToRenderRef.current, guid: componentGuid, focused: focusedTagState ? tagsToRenderRef.current.find(function (t) { return matchTags(t, focusedTagState, dataItemKey); }) : undefined })),
            props.loading && (React.createElement("span", { className: classNames('k-icon', { 'k-i-loading': props.loading }) })),
            hasValue && !disabled && (React.createElement("span", { onClick: onClear, className: "k-icon k-clear-value k-i-close", title: localization.toLanguageString(clear, messages[clear]), role: "button", tabIndex: -1, onMouseDown: function (e) { return e.preventDefault(); } })),
            React.createElement("select", { name: name, ref: selectRef, tabIndex: -1, "aria-hidden": true, title: label, style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: 'absolute', left: '50%' } },
                React.createElement("option", { value: props.valueMap ? props.valueMap.call(undefined, value) : value }))),
        React.createElement(Popup, { popupClass: popupSettings.popupClass, className: classNames('k-list-container k-group k-reset k-popup-dropdowntree', popupSettings.className, { 'k-rtl': dir === 'rtl' }), style: popupStyles, animate: popupSettings.animate, anchor: elementRef.current, show: isOpen, onOpen: onPopupOpened, onClose: onPopupClosed, appendTo: popupSettings.appendTo, ref: popupRef },
            props.filterable && (React.createElement("span", { className: "k-list-filter" },
                React.createElement("input", { className: "k-textbox", tabIndex: tabIndex, ref: inputRef, value: props.filter === undefined ? filterState : props.filter, onChange: onFilterChange, onKeyDown: onInputKeyDown }),
                React.createElement("span", { className: "k-icon k-i-zoom" }))),
            data.length > 0 ? (React.createElement(TreeView, { ref: treeViewRef, tabIndex: tabIndex, data: data, focusIdField: dataItemKey, textField: props.textField, checkField: checkField, checkIndeterminateField: checkIndeterminateField, expandField: props.expandField, childrenField: subItemsField, expandIcons: true, onItemClick: onChange, onCheckChange: onChange, onExpandChange: onExpand, checkboxes: true, item: props.item })) : (React.createElement(NoData, null, localization.toLanguageString(nodata, messages[nodata]))))));
    return label ? (React.createElement(FloatingLabel, { label: label, editorValue: hasValue, editorPlaceholder: placeholder, editorValid: isValid, editorDisabled: disabled, editorId: id, style: { width: style ? style.width : undefined }, children: multiselecttree, dir: dir })) : multiselecttree;
});
var propTypes = {
    opened: PropTypes.bool,
    disabled: PropTypes.bool,
    dir: PropTypes.string,
    tabIndex: PropTypes.number,
    accessKey: PropTypes.string,
    data: PropTypes.array,
    value: PropTypes.any,
    valueMap: PropTypes.func,
    placeholder: PropTypes.string,
    dataItemKey: PropTypes.string.isRequired,
    textField: PropTypes.string.isRequired,
    checkField: PropTypes.string,
    checkIndeterminateField: PropTypes.string,
    expandField: PropTypes.string,
    subItemsField: PropTypes.string,
    className: PropTypes.string,
    style: PropTypes.object,
    label: PropTypes.string,
    validationMessage: PropTypes.string,
    validityStyles: PropTypes.bool,
    valid: PropTypes.bool,
    required: PropTypes.bool,
    name: PropTypes.string,
    id: PropTypes.string,
    ariaLabelledBy: PropTypes.string,
    ariaDescribedBy: PropTypes.string,
    filterable: PropTypes.bool,
    filter: PropTypes.string,
    loading: PropTypes.bool,
    tags: PropTypes.arrayOf(PropTypes.shape({
        text: PropTypes.string,
        data: PropTypes.arrayOf(PropTypes.any)
    })),
    popupSettings: PropTypes.shape({
        animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.shape({
                openDuration: PropTypes.number,
                closeDuration: PropTypes.number
            })]),
        popupClass: PropTypes.string,
        className: PropTypes.string,
        appendTo: PropTypes.any,
        width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
        height: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
    }),
    onOpen: PropTypes.func,
    onClose: PropTypes.func,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func,
    onChange: PropTypes.func,
    onFilterChange: PropTypes.func,
    onExpandChange: PropTypes.func,
    item: PropTypes.func,
    listNoData: PropTypes.func
};
MultiSelectTree.displayName = 'KendoReactMultiSelectTree';
MultiSelectTree.propTypes = propTypes;
